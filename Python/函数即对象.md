# 函数即对象

## 1 函数是一等对象

**一等对象**(first-class object) 指的是满足以下条件的程序实体：

- 在运行时创建
- 能赋值给变量或数据结构中的元素
- 能作为参数传给函数
- 能作为函数的返回结果

在 Python 中，函数也符合上述条件，因此函数是一等对象。

> I have never considered Python to be heavily influenced by functional languages, no matter what people say or think. I was much more familiar with imperative languages such as C and Algol 68 and although I had made functions first-class objects, I didn't view Python as a functional programming language.     ——Gudio van Rossum

- `__doc__` 属性用于生成对象的帮助文本
- 可以将函数直接复制给变量，然后通过变量名调用该函数

### 1.1 高阶函数

**高阶函数**(higher-order function)：接受函数为参数，或把函数作为结果返回的函数。

内置函数 `sorted`、`map`、`filter`、`reduce` 等都属于高阶函数

- `map(function, iterable)`：返回一个可迭代对象，所含的项是把第一个参数（函数）应用到第二个参数（一个可迭代对象）中各个元素得到的结果
  - 在 Python 3 中，`map` 函数是惰性的，它会创建一个生成器，按需产出结果，因此能节省内存
- 可以用更为现代和方便的列表推导式和生成器表达式可以替代 `map` 和 `filter`
- `reduce` 归约函数来自 `functools` 模块，它的句法与 `map` 类似，作用是将一系列值归约成单个值
  - `reduce` 还有可选的第三个参数，作为初始值，但建议最好提供这个参数。如果可迭代对象为空，那么返回值就是这个初始值；否则在归约循环中，以这个初始值作为第一个参数（例如，对 `+`、`|`、`^` 来说，初始值应为 0，而对 `*` 和 `&` 来说，初始值应为 1）

- 内置的归约函数还有：
  - `all(iterable)`：`iterable` 中没有表示假值的元素时返回 `True`
  - `any(iterable)`：`iterable` 中只要有元素是真值就返回 `True`

### 1.2 匿名函数

**匿名函数**，即没有名称的函数，在 Python 中由 lambda 关键字实现。

- lambda 函数的主体只能是表达式，因此像 `while`、`try`，乃至 `=` 赋值等语句都不允许出现在 lambda 函数的主体部分
- 但是可以用 `:=` 赋值表达式，不过这种情况下的 lambda 函数可能过于复杂，建议用 `def` 定义方法重构函数
- lambda 函数主要的作用是作为高阶函数的参数，除此之外很少会用到 lambda 函数

### 1.3 可调用对象

可调用对象指的是可以使用调用运算符 `()` 的对象，可以用内置的 `callable()` 函数判断。Python 3.9 后的版本提供以下几种可调用对象：

- 用户定义的函数：使用 `def` 语句或 `lambda` 表达式创建的函数
- 内置函数：使用 C 语言（CPython）实现的函数
- 内置方法：使用 C 语言实现的方法
- 方法：在类主体中定义的函数
- 类：调用类时运行 `__new__` 方法创建一个实例，然后运行 `__init__` 方法来初始化实例，最后再将实例返回给调用方
- 类的实例：若类定义了 `__call__` 方法，那么它的实例可以作为函数调用
- 生成器函数：主体中有 `yield` 关键字的函数或方法。调用生成器函数返回一个生成器对象
- 原生协程函数：使用 `async def` 定义的函数或方法。调用原生协程函数返回一个协程对象
- 异步生成器函数：使用 `async def` 定义，且主体中有 `yield` 关键字的函数或方法。调用异步生成器函数返回一个异步生成器，供 `async for` 使用

### 1.4 用户定义的可调用类型

通过实现实例方法 `__call__`，我们便可以使任何 Python 对象都能像函数一样被调用。例如

```python
import random

class BingoCage:

    def __init__(self, items):
        self._items = list(items)
        random.shuffle(self._items)

    def pick(self):
        try:
            return self._items.pop()
        except IndexError:
            raise LookupError('pick from empty BingoCage')

    def __call__(self):
        return self.pick()
```

运行结果为

```python
>>> bingo = BingoCage(range(3))
>>> bingo.pick()
0
>>> bingo()
1
>>> callable(bingo)
True
```

- 实现 `__call__` 方法后，必须在内部维护一个状态，让它在多次调用之间存续（涉及到闭包）
- `__call__` 的另一个用处是实现装饰器

### 1.5 形参声明句法

#### 1.5.1 仅限关键字参数

定义函数时，在参数列表中加入参数 `*`，`*` 后面（右边）的参数就是仅限关键字参数，即调用时一定要指出参数名称的参数。

```python
>>> def f(a, *, b):
...     return a, b
...     
>>> f(1, b=2)
(1, 2)
>>> f(1, 2)
Traceback (most recent call last):
File "<python-input-2>", line 1, in <module>
    f(1, 2)
    ~^^^^^^
TypeError: f() takes 1 positional argument but 2 were given
```

#### 1.5.2 仅限位置参数

定义函数时，在参数列表中加入参数 `/`，`/` 前面（左边）的参数就是仅限位置参数，即调用时不能指出参数名称的参数。在 `/` 后面的参数不会受到影响

```python
>>> def divmod(a, b, /):
...     return (a // b, a % b)
... 
>>> divmod(10, 4)
(2, 2)
>>> divmod(a=10, b=4)
Traceback (most recent call last):
File "<python-input-5>", line 1, in <module>
    divmod(a=10, b=4)
    ~~~~~~^^^^^^^^^^^
TypeError: divmod() got some positional-only arguments passed as keyword arguments: 'a, b'
```

> [!note]
>
> Python 中可以在函数参数列表中使用 `*args` 和 `**kwargs` 捕获剩余的位置参数和关键字参数
>
> ```python
> def tag(name, *content, class_=None, **attrs):
>  """Generate one or more HTML tags"""
>  if class_ is not None:
>  attrs['class'] = class_
>  attr_pairs = (f' {attr}="{value}"' for attr, value
>  in sorted(attrs.items()))
>  attr_str = ''.join(attr_pairs)
>  if content:
>  elements = (f'<{name}{attr_str}>{c}</{name}>'
>  for c in content)
>  return '\n'.join(elements)
>  else:
>  return f'<{name}{attr_str} />'
> ```
>
> 在 `*args` 之后的参数只能按关键字传入，比如例子中的 `class_`

### 1.6 函数式编程

由于一等函数和 `operator`、`functools`等模块，Python 也支持函数式编程风格

#### 1.6.1 operator 模块

在函数式编程中，经常需要把算术运算符当作函数使用，而 Python 的 `operator` 模块提供了这样的函数。下面列出了 `operator` 模块中定义的部分函数列表（省略以 `_` 开头的名称，因为它们基本上是实现细节）：

```python
>>> [name for name in dir(operator) if not name.startswith('_')]
['abs', 'add', 'and_', 'attrgetter', 'call', 'concat', 'contains', 
'countOf', 'delitem', 'eq', 'floordiv', 'ge', 'getitem', 'gt', 'iadd', 
'iand', 'iconcat', 'ifloordiv', 'ilshift', 'imatmul', 'imod', 'imul', 
'index', 'indexOf', 'inv', 'invert', 'ior', 'ipow', 'irshift', 'is_', 
'is_not', 'isub', 'itemgetter', 'itruediv', 'ixor', 'le', 'length_hint', 
'lshift', 'lt', 'matmul', 'methodcaller', 'mod', 'mul', 'ne', 'neg', 
'not_', 'or_', 'pos', 'pow', 'rshift', 'setitem', 'sub', 'truediv', 
'truth', 'xor']
```

- 大部分函数的功能可以从它们的名称中直接看出来
- 以 `i` 开头的函数对应增量赋值运算符的形式（例如 `+=`、`*=`）：若第一个参数是可变类型，则函数会就地修改第一个参数；否则的话直接返回运算结果，不修改参数

`operator` 模块中还有一些工厂函数：

- `itemgetter`：从序列中读取项。该函数接受单个或多个索引（`int` 类型），返回一个函数，用于提取序列中对应索引处的项，对于多个索引会打包成一个元组

  ```python
  >>> metro_data = [
  ...     ('Tokyo', 'JP', 36.933),
  ...     ('Delhi NCR', 'IN', 21.935),
  ...     ('Mexico City', 'MX', 20.142),
  ...     ('New York-Newark', 'US', 20.104),
  ...     ('Sao Paulo', 'BR', 19.648),
  ... ]                                                                                                                               
  >>> from operator import itemgetter                                                                                                 
  >>> cc_name = itemgetter(1, 0)                                                                                                      
  >>> for city in metro_data:
  ...     print(cc_name(city))
  ... 
  ('JP', 'Tokyo')
  ('IN', 'Delhi NCR')
  ('MX', 'Mexico City')
  ('US', 'New York-Newark')
  ('BR', 'Sao Paulo')
  ```

- `attrgetter`：从对象中读取属性。该函数接受单个或多个属性名（`str` 类型），返回一个函数，用于提取对象中对应的属性，对于多个属性会打包成一个元组

  - 如果属性名中包含 `.`，那么函数就会深入嵌套对象，检索属性

  ```python
  >>> from collections import namedtuple
  >>> Metropolis = namedtuple('Metropolis', 'name cc pop')
  >>> metro_areas = [Metropolis(name, cc, pop) for name, cc, pop in metro_data]
  >>> metro_areas[0]
  Metropolis(name='Tokyo', cc='JP', pop=36.933)
  >>> from operator import attrgetter
  >>> name_pop = attrgetter('name', 'pop')
  >>> 
  >>> for city in sorted(metro_areas, key=attrgetter('pop')):
  ...     print(name_pop(city))
  ... 
  ('Sao Paulo', 19.648)
  ('New York-Newark', 20.104)
  ('Mexico City', 20.142)
  ('Delhi NCR', 21.935)
  ('Tokyo', 36.933)
  ```

- `methodcaller`：会在对象上调用参数指定的方法。第一个参数为 `str` 类型，表示方法名称，后面的参数作为该方法的参数（或者说冻结了一些参数）；返回的是一个可调用的方法

  ```python
  >>> from operator import methodcaller
  >>> s = 'The time has come'
  >>> upcase = methodcaller('upper')
  >>> upcase(s)
  'THE TIME HAS COME'
  >>> hyphenate = methodcaller('replace', ' ', '-')
  >>> hyphenate(s)
  'The-time-has-come'
  ```

#### 1.6.2 functools.partial 冻结参数

另一种可以冻结参数的函数是 `functools.partial`，它可以根据提供的可调用对象产生一个新可调用对象，为原可调用对象的某些参数绑定预定的值。

- 该函数返回的是一个 `functools.partial` 对象
- 该对象提供了访问原函数、固定参数和关键字参数的属性 `.func` 、`.args` 和 `.keywords`

```python
>>> from tagger import tag
>>> tag
<function tag at 0x0000020BC5E68B80>
>>> from functools import partial
>>> picture = partial(tag, 'img', class_='pic-frame')
>>> picture(src='wumpus.jepg')
'<img class="pic-frame" src="wumpus.jepg" />'
>>> picture
functools.partial(<function tag at 0x0000020BC5E68B80>, 'img', class_='pic-frame')   
>>> picture.func
<function tag at 0x0000020BC5E68B80>
>>> picture.args
('img',)
>>> picture.keywords
{'class_': 'pic-frame'}
```

